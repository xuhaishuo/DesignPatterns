# DesignPatterns
# 设计模式

## 适应设计模式

### Iterator模式

* **一个一个的遍历**

* **按照统一的方法遍历集合中的元素**

* 引入Iterator后，可以将遍历和实现分离开
* 设计模式的作用就是帮助我们编写可复用的类。所谓 “可复用”，就是指将类实现为 “组件”，当一个组件发生变化时，不需要对其他的组件进行修改或是只需要很小的修改即可应对
* 不要使用具体类来变成名要优先使用抽象类和接口来编程



### Adapter模式

* 加个 “适配器” 以便于复用
* Adapter模式也被称为 Wrapper模式
* Adapter模式主要有两种
  * **类适配器模式（使用继承的适配器）**
  * **对象适配器模式（使用委托的适配器）**
* **Adapter模式用于填补具有不同接口(API)的两个类之间的缝隙**



## 交给子类

### Template Method模式

* 将具体处理交给子类
* Template Method 模式是带有模板功能的模式，组成模板的方法被定义在父类中
* 不同的子类实现不同的具体处理，当父类的模板方法被调用时程序行为也会不同。但是，不论子类中的具体实现如何，处理的流程都会按照父类中所定义的那行进行
* **在父类中定义处理的流程，在子类中实现具体内容**



### Factory Method模式

* 将实例的生成交给子类
* **在Factory Method模式中，父类决定实例的生成方式，但并不决定所要生成的具体的类，具体的处理全部交给子类负责**
* 如果仅阅读一个类的代码，是很难理解这个类的行为的。必须要理解父类中所定义的处理的框架和它里面所使用的抽象方法，然后阅读代码，了解这些抽象方法在子类中的实现才行
* 在设计模式中，多个类和接口扮演各自的角色，互相协作进行工作。在分析设计模式时，不应当将其中一个类单独拿出来分析，必须着眼于类和接口之间的相互关系



## 生成实例

### Singleton模式

* 只有一个实例



### Prototype模式

* 通过复制生成实例
* **根据现有实例来生成实例**，使用 clone 创建实例的副本
* 实现了 **Cloneable** 接口的类的实例可以调用 clone 方法进行复制，clone 方法的返回值是复制出的新的实例(clone 方法内部所进行的处理是分配与要复制的实例同样大小的内存空间，接着将要复制的实例中的字段的值复制到所分配的内存空间中去)
* clone 方法进行的是浅复制



### Builder模式

* 组装具有复杂结构的实例
* 在一个类中以委托的形式存放另一个类的引用，可以在一个类中，调用另一个类的方法；相当于一个类中，组装了多个其他的类



### Abstract Factory模式

* 将关联零件组装成产品
* **抽象工厂的工作是将 “抽象零件” 组装成 “抽象产品”**
* 在 Template Method 和 Builder 模式中，子类这一层负责方法的具体实现。在 Abstract Factory 模式中也是一样。在子类这一层中有具体的工厂，它负责将具体的零件组装成具体的产品
* **父类定义抽象工厂，子类实现具体的工厂来组装产品零件**



## 分开考虑

### Bridge模式

* 将类的功能层次结构与实现层次结构分离
* Bridge 模式的作用是将两样东西连接起来，它们分别是 类的功能层次结构 与 类的实现层次结构
* 类的层次结构的作用
  * 希望增加新的功能时，创建派生类(子类)，父类具有基本功能，子类增加新的功能，这就是 类的功能层次结构
  * 希望增加新的实现时，父类通过声明抽象方法来定义接口(API)，子类通过实现具体方法来实现接口(API)，这就是 类的实现层次结构
* **通过 委托 和 继承 来增加新的功能和新的实现**；继承是强关联关系，委托是弱关联关系，委托可以弱化类之间的关联关系。



### Strategy模式

* 整体地替换算法 =》 **策略模式**
* 通常在编程时算法会被写在具体地方法中。Strategy 模式却特意将算法与其他部分分离开来，只是定义了与算法相关地接口(API)，然后再程序中以委托的方式来使用算法。这样看起来程序复杂了，其实并不是的。使用委托这种弱关联关系可以很方便地整体替换算法
* **借助委托，实现算法地替换，特别是动态替换**



## 一致性

### Composite模式

* 容器与内容的一致性
* 文件夹是一种容器结构、递归结构，文件夹内可以放文件、文件夹，内部的文件夹又可以递归的放文件、文件夹...；Composite 模式就是用于创造出这样结构的模式，能够使容器与内容具有一致性，创造出递归结构的模式就是Compisite 模式
* **容器和内容具有一致性(实现了同一个接口 或者 继承了同一个类)，并且可以创建出递归结构**



### Decorator模式

* 装饰边框与被装饰物的一致性
* **将被装饰类 传入到 装饰类中，在不改变被装饰类的前提下对其进行增强(装饰)，主要使用的是 委托**
* 接口(API)的透明性
  * 在Decorator模式中，装饰边框与被装饰物具有一致性(具备相同的接口 或 继承同一个类)
  * 得益于接口的透明性，Decorator模式中也形成了 Composite模式中的递归结构。不过，Decorator模式虽然与Composite模式一样，都具有递归结构，但是它们的使用目的不同。Decorator模式的主要目的是通过增添装饰物来增加对象的功能
* 在不改变装饰物的前提下增加功能
  * 在Decorator模式中，装饰边框与被装饰物具有相同的接口(API)。虽然接口(API)是相同的，但是越装饰，功能则越多。
  * Decorator模式使用了委托
* 可以动态地增加功能
  * Decorator模式中使用了委托，它使类之间形成了弱关联关系。因此，不用改变框架代码，就可以生成一个与其他对象具有不同关系的新对象
* 只需要一些装饰物即可添加许多功能
  * 使用Decorator模式可以为程序添加许多功能。只需要准备一些装饰边框，即使这时装饰边框都只具有非常简单的功能，也可以将它们自由组合成为新的对象
  * Decorator模式就是可以应对这种多功能对象的需求的一种模式



## 访问数据结构

### Visitor模式

* 访问数据结构并处理数据
* **在Visitor模式中，数据结构与处理被分离开来。编写一个表示“访问者”的类来访问数据结构中的元素，并把对各元素的处理交给访问者类。这样，当需要增加新的处理时，只需要编写新的访问者，然后让数据结构可以接受访问者的访问即可**
* **Visitor模式的目的是将出路从数据结构中分离出来**。数据结构很重要，它能将元素集合和关联在一起。但是，保存数据结构与以数据结构为基础进行处理是两种不同的东西
* **开闭原则**
  * 对扩展开放，对修改关闭
  * 在设计类时，若无特殊理由，必须要考虑到将来可能会扩展类。绝不能毫无理由地禁止扩展类，这就是“对扩展是开放的”
  * 如果在每次扩展类时都需要修改现有的类就太麻烦了。所以我们需要在不用修改现有类的前提下能够扩展类，这就是“对修改时关闭的”
  * 对扩展开放、对修改关闭的类具有高可复用性，可作为组件复用



### Chain of Responsibility模式

* 推卸责任 =》 当外部请求程序进行某个处理，但程序暂时无法直接决定由哪个对象负责处理时，就需要推卸责任
* **将多个对象组成一条职责链，然后按照它们在职责链上的顺序一个一个地找出到底应该谁来负责处理**
* 使用 Chain of Responsibility模式 可以弱化“请求方” 和“处理方”之间地关联关系，让双发各自都成为可独立复用地组件。此外，程序还可以应对其他需求，如根据情况不同，负责处理地对象也会发生变化等
* 使用 Chain of Responsibility模式，通过委托推卸责任，就可以根据情况变化动态地组织职责链
* 个人理解：类似于链表，当前可以处理就处理，处理不了就next指向下一个对象



## 简单化

### Facade模式

* 简单窗口
* **使用Facade模式可以为互相关联在一起地错综复杂地类整理出高层接口(API)。其中的Facade角色可以让系统对外只有一个简单的接口(API)。而且，Facade角色还会考虑到系统内部各个类之间的责任关系和依赖关系，按照正确的顺序调用各个类**
* 个人理解：上层暴露一个接口(API)，使用时只使用这个上层的接口，接口的内部并不关心。具体的各个实现，以及错综复杂的调用，则由这个上层接口来实现



### Mediator模式

* 仲裁者模式。在 Mediator模式中，“仲裁者”被称为 Mediator，各组员被称为 Colleague。
* **Mediator 模式不让互相关联的对象之间进行任何通信，而是让它们向仲裁者进行报告**
* 个人理解：类和类的实例之间不再调用通信，由一个统一的来管理，并由它来进行转发通信



## 管理状态

### Observer模式

* 发送状态变化通知 =》 观察者模式
* **在Observer 模式中，当观察对象的状态发生变化时，会通知观察者。Observer模式适用于根据对象状态进行相应处理的场景**
* Observer本来的意思是“观察者”，但实际上 Observer角色并非主动地去观察，而是被动地接受来自Subject角色地通知。因此，Observer模式也被称为 Publish-Subscribe（发布-订阅）模式
* MVC中的Model和View的关系与Subject角色和Observer角色的关系相对应
* Java类库中的 java.util.Observer 接口 和 java.util.Observable 类就是一种 Observer模式
* 个人理解：被观察者改变时，手动通知观察者，观察者得到信息后开始响应



### Memento模式

* 保存对象状态
* Memento模式可以实现应用程序的以下功能
  * Undo (撤销)
  * Redo (重做)
  * History (历史快照)
  * Snapshot (快照)
* Memento 模式就是一个这样的设计模式，**它事先将某个时间点的实例的状态保存下来，之后在有必要时，再将实例恢复至当时的状态**
* **Memento模式 记录和保存对象当前状态**，在尽可能不公开对象内部状态的前提下保存对象状态
* 个人理解：用一个类的属性保存另一个类实例的状态，这个实例就可以根据不同的场景条件进行撤销会原状态，也可以将当前新状态保存起来



### State模式

* 用类保存状态
* **State模式中，用类来保存状态。以类来保存状态后，就可以通过切换类来方便地改变对象地状态**
* 在State模式中，用类来表示状态，并为每一种具体地状态都定义一个相应地类。并以此将复杂地程序分解开来
* 在State模式中，如何编程，以实现“依赖于状态地处理”？
  * 定义接口，声明抽象方法
  * 定义多个类，实现具体方法
* 个人理解：将 if(xxx) else if (yyy) else if (zzz) ... ；中的条件判断抽成一个个的类，根据条件状态切换类，来执行api



## 避免浪费

### Flyweight模式

* 共享对象，避免浪费
* Flyweight是“轻量级”的意思，该设计模式的作用就是让对象变“轻”
* 当程序需要大量对象时，如果都使用new关键字来分配内存，将消耗大量内存空间。关于Flyweight模式，就是“**通过尽量共享实例来避免 new 出实例**”。**当需要某个实例时，并不总时通过new来生成实例，而是尽量共用已经存在的实例**
* 如果改变了被共享的实例，那么会对所有使用该实例的地方都产生影响。因此，需要注意区分应该共享的信息和不应该共享的信息
* 个人理解：可以用一个map来保存所有的实例，需要创建实例前，先去map中用key查询value，如果存在了就不再新建实例了，如果不存在再新建实例并存到map中



### Proxy模式

* 只在必要时生成实例
* **代理模式 =》让代理人完成工作，除非那些工作必须由本人完成**
* 代理和委托
  * 代理人只代理他能解决的问题。当遇到他不能解决的问题时，还是会“转交”给本人去解决。这里的“转交”其实就是“委托”
* 各种代理模式
  * **Virtual Proxy (虚拟代理)** =》 当真正需要实例时，它才生成和初始化实例
  * **Remote Proxy (远程代理)** =》其实就是动态代理，使用 Java的RMI (RemoteMethodInvocation)
  * **Access Proxy** =》用于在调用 RealSubject角色的功能时设置访问限制



### Command模式

* 命令也是类
* 命令模式
* **通过用对象表示 “命令” 来保存命令历史记录和重复执行命令**



### Interpreter模式

* 语法规则也是类
* 在Interpreter模式中，程序要解决的问题会被用非常简单的“迷你语言”表述出来，即用“迷你语言”编写的“迷你程序”把具体的问题表述出来。迷你程序是无法单独工作的，我们还需要用Java语言来编写一个负责**“翻译”(interpreter)**的程序。翻译程序会理解迷你语言，并解释和运行迷你程序。这段翻译程序也被称为**翻译器**。这样，当需要解决的问题发生变化时，不需要修改Java语言程序，只需要修改迷你语言程序即可
* 有哪些迷你语言
  * 正则表达式
  * 检索表达式
  * 批处理语言
  * ...






